/*********************************************************************************************************************
* DAVE APP Name : CPU_CTRL_XMC4       APP Version: 4.0.18
*
* NOTE:
* This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
*********************************************************************************************************************/

/**
 * @cond
 ***********************************************************************************************************************
 *
 * Copyright (c) 2015-2020, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-16:
 *     - Initial version<br>
 *
 * 2015-08-28:
 *     - Added exceptions and MPU settings
 *
 * 2015-11-30:
 *     - Added disable write buffer
 *
 * 22-Nov-2018:
 *     - Fixed PMU_FLASH_WS definition for XMC4300 devices
 *
 * @endcond
 *
 */
/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include "xmc_scu.h"
#include "xmc_gpio.h"
#include "cpu_ctrl_xmc4.h"
/***********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/
#if ((UC_SERIES == XMC48) || (UC_SERIES == XMC47) || (UC_SERIES == XMC43)) 
#define PMU_FLASH_WS          (0x4U)
#elif ((UC_SERIES == XMC45) || (UC_SERIES == XMC44))
#define PMU_FLASH_WS          (0x3U)
#else
#define PMU_FLASH_WS          (0x2U)
#endif

#define REGION_VALID (0x10U)

#define START_ADDR_32B   (0x05U)
#define START_ADDR_64B   (0x06U)
#define START_ADDR_128B  (0x07U)
#define START_ADDR_256B  (0x08U)
#define START_ADDR_512B  (0x09U)
#define START_ADDR_1KB   (0x0AU)
#define START_ADDR_2KB   (0x0BU)
#define START_ADDR_4KB   (0x0CU)
#define START_ADDR_8KB   (0x0DU)
#define START_ADDR_16KB  (0x0EU)
#define START_ADDR_32KB  (0x0FU)
#define START_ADDR_64KB  (0x10U)
#define START_ADDR_128KB (0x11U)
#define START_ADDR_256KB (0x12U)
#define START_ADDR_512KB (0x13U)
#define START_ADDR_1MB   (0x14U)
#define START_ADDR_2MB   (0x15U)
#define START_ADDR_4MB   (0x16U)
#define START_ADDR_8MB   (0x17U)
#define START_ADDR_16MB  (0x18U)
#define START_ADDR_32MB  (0x19U)
#define START_ADDR_64MB  (0x1AU)
#define START_ADDR_128MB (0x1BU)
#define START_ADDR_256MB (0x1CU)
#define START_ADDR_512MB (0x1DU)
#define START_ADDR_1GB   (0x1EU)
#define START_ADDR_2GB   (0x1FU)

#define REGION_SIZE_32B (0x04U << MPU_RASR_SIZE_Pos)
#define REGION_SIZE_64B (0x05U << MPU_RASR_SIZE_Pos)
#define REGION_SIZE_128B (0x06U << MPU_RASR_SIZE_Pos)
#define REGION_SIZE_256B (0x07U << MPU_RASR_SIZE_Pos)
#define REGION_SIZE_512B (0x08U << MPU_RASR_SIZE_Pos)
#define REGION_SIZE_1KB (0x09U << MPU_RASR_SIZE_Pos)
#define REGION_SIZE_2KB (0x0AU << MPU_RASR_SIZE_Pos)
#define REGION_SIZE_4KB (0x0BU << MPU_RASR_SIZE_Pos)
#define REGION_SIZE_8KB (0x0CU << MPU_RASR_SIZE_Pos)
#define REGION_SIZE_16KB (0x0DU << MPU_RASR_SIZE_Pos)
#define REGION_SIZE_32KB (0x0EU << MPU_RASR_SIZE_Pos)
#define REGION_SIZE_64KB (0x0FU << MPU_RASR_SIZE_Pos)
#define REGION_SIZE_128KB (0x10U << MPU_RASR_SIZE_Pos)
#define REGION_SIZE_256KB (0x11U << MPU_RASR_SIZE_Pos)
#define REGION_SIZE_512KB (0x12U << MPU_RASR_SIZE_Pos)
#define REGION_SIZE_1MB (0x13U << MPU_RASR_SIZE_Pos)
#define REGION_SIZE_2MB (0x14U << MPU_RASR_SIZE_Pos)
#define REGION_SIZE_4MB (0x15U << MPU_RASR_SIZE_Pos)
#define REGION_SIZE_8MB (0x16U << MPU_RASR_SIZE_Pos)
#define REGION_SIZE_16MB (0x17U << MPU_RASR_SIZE_Pos)
#define REGION_SIZE_32MB (0x18U << MPU_RASR_SIZE_Pos)
#define REGION_SIZE_64MB (0x19U << MPU_RASR_SIZE_Pos)
#define REGION_SIZE_128MB (0x1AU << MPU_RASR_SIZE_Pos)
#define REGION_SIZE_256MB (0x1BU << MPU_RASR_SIZE_Pos)
#define REGION_SIZE_512MB (0x1CU << MPU_RASR_SIZE_Pos)
#define REGION_SIZE_1GB (0x1DU << MPU_RASR_SIZE_Pos)
#define REGION_SIZE_2GB (0x1EU << MPU_RASR_SIZE_Pos)
#define REGION_SIZE_4GB (0x1FU << MPU_RASR_SIZE_Pos)

#define REGION_TYPE_FLASH        (0x2U << MPU_RASR_B_Pos)
#define REGION_TYPE_SRAM         (0x6U << MPU_RASR_B_Pos)
#define REGION_TYPE_EXTRAM       (0x7U << MPU_RASR_B_Pos)
#define REGION_TYPE_PERIPHERAL   (0x5U << MPU_RASR_B_Pos)

#define REGION_ACCESS_PERMISION_PV_NA_U_NA (0x0 << MPU_RASR_AP_Pos)
#define REGION_ACCESS_PERMISION_PV_RW_U_NA (0x1 << MPU_RASR_AP_Pos)
#define REGION_ACCESS_PERMISION_PV_RW_U_R  (0x2 << MPU_RASR_AP_Pos)
#define REGION_ACCESS_PERMISION_PV_RW_U_RW (0x3 << MPU_RASR_AP_Pos)
#define REGION_ACCESS_PERMISION_PV_R_U_NA  (0x5 << MPU_RASR_AP_Pos)
#define REGION_ACCESS_PERMISION_PV_R_U_R  (0x6 << MPU_RASR_AP_Pos)

extern uint32_t __Vectors;
/**********************************************************************************************************************
* DATA STRUCTURES
**********************************************************************************************************************/
CPU_CTRL_XMC4_t CPU_CTRL_XMC4_0 =
{
  .initialized = false
};	


const uint32_t mpu_table[] =
{ 
  /* Configure region 0 */
  ((0 & (~((1 << START_ADDR_256KB) - 1))) | REGION_VALID | 0),       
  (0 | REGION_ACCESS_PERMISION_PV_RW_U_RW |
   REGION_TYPE_PERIPHERAL |   (0 << MPU_RASR_SRD_Pos) | 
   REGION_SIZE_256KB |  1), 
  /* Configure region 1 */
  ((0 & (~((1 << START_ADDR_128KB) - 1))) | REGION_VALID | 1),       
  (0 | REGION_ACCESS_PERMISION_PV_RW_U_RW |
   REGION_TYPE_FLASH |  0 | 
   REGION_SIZE_128KB |  0), 

  /* Configure region 2 */
  ((0 & (~((1 << START_ADDR_128KB) - 1))) | REGION_VALID | 2),       
  (0 | REGION_ACCESS_PERMISION_PV_RW_U_RW |
   REGION_TYPE_FLASH |  0 | 
   REGION_SIZE_128KB |  0), 

  /* Configure region 3 */
  ((0 & (~((1 << START_ADDR_128KB) - 1))) | REGION_VALID | 3),       
  (0 | REGION_ACCESS_PERMISION_PV_RW_U_RW |
   REGION_TYPE_FLASH |  0 | 
   REGION_SIZE_128KB |  0), 

  /* Configure region 4 */
  ((0 & (~((1 << START_ADDR_128KB) - 1))) | REGION_VALID | 4),       
  (0 | REGION_ACCESS_PERMISION_PV_RW_U_RW |
   REGION_TYPE_FLASH |  0 | 
   REGION_SIZE_128KB |  0), 

  /* Configure region 5 */
  ((0 & (~((1 << START_ADDR_128KB) - 1))) | REGION_VALID | 5),       
  (0 | REGION_ACCESS_PERMISION_PV_RW_U_RW |
   REGION_TYPE_FLASH |  0 | 
   REGION_SIZE_128KB |  0), 

  /* Configure region 6 */
  ((0 & (~((1 << START_ADDR_128KB) - 1))) | REGION_VALID | 6),       
  (0 | REGION_ACCESS_PERMISION_PV_RW_U_RW |
   REGION_TYPE_FLASH |  0 | 
   REGION_SIZE_128KB |  0), 

  /* Configure region 7 */
  ((0 & (~((1 << START_ADDR_128KB) - 1))) | REGION_VALID | 7),       
  (0 | REGION_ACCESS_PERMISION_PV_RW_U_RW |
   REGION_TYPE_FLASH |  0 | 
   REGION_SIZE_128KB |  0), 

}
;
void SystemCoreSetup(void)
{
  uint32_t temp;

  NVIC_SetPriorityGrouping(1U);
	
  /* relocate vector table */
  __disable_irq();

#if !defined(__TASKING__)
  SCB->VTOR = (uint32_t)(&__Vectors);
#endif

  __DSB();
  __enable_irq();
	
#if ((__FPU_PRESENT == 1) && (__FPU_USED == 1))
  SCB->CPACR |= ((3UL << 10*2) |                 /* set CP10 Full Access */
				 (3UL << 11*2)  );               /* set CP11 Full Access */
#endif
  /* Set flash wait states */
  temp = FLASH0->FCON;
  temp &= ~FLASH_FCON_WSPFLASH_Msk;
  temp |= PMU_FLASH_WS;
  FLASH0->FCON = temp;


  /* Disable divide by zero trap */
  SCB->CCR &= ~SCB_CCR_DIV_0_TRP_Msk; 

  /* Disable unaligned memory access trap */
  SCB->CCR &= ~SCB_CCR_UNALIGN_TRP_Msk; 

  /* Set priority of memory managment fault */
  NVIC_SetPriority((IRQn_Type)MemoryManagement_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0,0));
  /* Enable memory management fault */
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;


  /* Disable bus fault */
  SCB->SHCSR &= ~SCB_SHCSR_BUSFAULTENA_Msk;

  /* Disable usage fault */
  SCB->SHCSR &= ~SCB_SHCSR_USGFAULTENA_Msk;

__DMB();
MPU->CTRL = 0;
for(uint8_t i= 0; i<8; i++)
{
 MPU->RBAR = mpu_table[i*2];
 MPU->RASR = mpu_table[(i*2) + 1];
}
MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk | MPU_CTRL_HFNMIENA_Msk;
__DSB();
__ISB();

}
